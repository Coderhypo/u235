---
title: "TCP超时重传及流量控制"
date: 2020-12-24T09:07:42+08:00
draft: true
---

当TCP发出报文之后一段时间后，没能收到对方的确认包，那么可以认为时数据包已经**超时**，这时就需要**重传**。
在数据的发送方与接收方之间，需要协调发送与接收速率：发送太快接收太慢，那么接收方数据来不及处理缓冲区不足，数据包可能会被丢弃;发送太慢，就白白浪费带宽，占用发送方的时间。

## 重传

一个报文段从发送方发出到确认回到发送方，这个时间称为一个`RTT`，依据这个`RTT`，可以设定一个时间，当超出这个时间就认为数据包已经**超时**，这个时间就是`RTO`，即`Retry Time Out`.

当数据包需要重传时，很可能是由于对面已经意外关闭，网络连接断开，或者中间网络恶化等等。重试1次不一定成功，因此需要每隔一段时间重试一次。TCP一般实现，每次重传间隔时间加倍，这被称为**二进制指数退避(binary exponential backoff)**，多次重试后就应当考虑放弃连接。

在建立连接时，我们可能遇到发起`SYN`失败，或对`SYN`返回`ACK`失败：

`net.ipv4.tcp_syn_retries` 用于控制`SYN`发送失败多少次应该放弃连接
`net.ipv4.tcp_asynack_retries` 用于控制对`SYN`的`ACK`发送失败多少次应该放弃连接

TCP定义了`R1`和`R2`两个阈值来决定如何重传同一个报文段，当达到`R1`时，IP层将需要考虑重新评估当前的IP传输路径；当达到`R2`时，则放弃当前连接。在Linux中，他们分别是：

`net.ipv4.tcp_retries1` 以及 `net.ipv4.tcp_retries2`.

## 超时





